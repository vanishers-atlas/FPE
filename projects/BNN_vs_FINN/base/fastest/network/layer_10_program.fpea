{
	//*
		This constants are free to change to match the target layer.
		Currently no speacal cases have been found
	*//
	DEF input_neurons  4096 ;
	DEF output_neurons 512 ;
	
	// Common constants deviced from other constants
	
	// Define meaningfully names for Block access managers
	DEF inputs       0 ;
	DEF parameters   1 ;
	
	RESET BAM[inputs] ;
	RESET BAM[parameters] ;
	 NOP ;
	
	// Read input data to RAM
	ZOL (input_neurons)
	{
		MOV( GET[0]<ADV>, RAM[BAM[inputs]<FORWARD>] ) ;
	}
	
	// Process each neuron in turn
	ZOL (output_neurons)
	{
		// BAM[inputs] will have wrapped around to 0 at this point
		// therefore no need to reset
		
		// Preform XOR and popcount weight
		XOR ( RAM[BAM[inputs]<FORWARD>], ROM[BAM[parameters]<FORWARD>], REG[0] ) ; // Overwrite popcountA
		XOR ( RAM[BAM[inputs]<FORWARD>], ROM[BAM[parameters]<FORWARD>], REG[1] ) ; // Overwrite popcountB
		ZOL ((input_neurons - 2)/2)
		{
			XOR ( RAM[BAM[inputs]<FORWARD>], ROM[BAM[parameters]<FORWARD>], ACC ) ;
			ADD ( REG[0], ACC, REG[0]) ;
			XOR ( RAM[BAM[inputs]<FORWARD>], ROM[BAM[parameters]<FORWARD>], ACC ) ;
			ADD ( REG[1], ACC, REG[1]) ;
		}
		
		// Add popcountA and popcountB to get full popcount
		// At this point popcountB (REG[1]) isn't fetchable, but is still in ACC
		ADD ( REG[0], ACC, ACC) ;
		
		// output the most significent bit of the difference between the popcount and the threashold
		// Evalation to a sign function on the difference
		SUB(ROM[BAM[parameters]<FORWARD>], ACC, ACC); // Threadhold - popcount so 0 MSB - negative value
		RSH(ACC, 13, PUT[0]); // Shift by lg(3 * 3 * input_d + 1) - 1 bits to get the MSB
	}
	NOP ;
}
